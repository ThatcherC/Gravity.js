//Simulates and draws Particles
//TODO: improve integration code. Why not add accelerations to both particles being compared?
function init(){var t=document.getElementById("canvas"),e=document.getElementById("controlbox")
t.width=window.innerWidth-30,t.height=window.innerHeight-20,width=t.width,height=t.height,context=t.getContext("2d"),window.addEventListener("mousedown",mouseDownListener,!1),e.onmouseover=function(){onControlBox=!0},e.onmouseout=function(){onControlBox=!1}}function main(){starttime=Date.now(),integrate(),draw(),frametime=Date.now()-starttime}function mouseDownListener(t){onControlBox||(console.log("down"),startCoords[0]=t.clientX,startCoords[1]=t.clientY,endCoords[0]=t.clientX,endCoords[1]=t.clientY,window.addEventListener("mousemove",mouseMoveListener,!1),window.addEventListener("mouseup",mouseUpListener,!1))}function mouseMoveListener(t){endCoords[0]=t.clientX,endCoords[1]=t.clientY}function mouseUpListener(t){console.log("up"),window.removeEventListener("mousemove",mouseMoveListener),window.removeEventListener("mouseup",mouseUpListener)
var e=new Particle(newMass,startCoords[0],startCoords[1],endCoords[0]-startCoords[0],endCoords[1]-startCoords[1])
particleList.push(e),startCoords=[-1,-1],endCoords=[-1,-1]}function setNewMass(t){console.log(t),newMass=t}function integrate(){for(var t=new Array,e=0;e<particleList.length;e++){for(var o=particleList[e],r=0,i=0,s=0;s<particleList.length;s++)if(otherParticle=particleList[s],o!=otherParticle&&!o.collided&&!otherParticle.collided){var a=otherParticle.x-o.x,n=otherParticle.y-o.y,l=Math.sqrt(a*a+n*n)
if(l<o.radius/1.5+otherParticle.radius/1.5){o.collided=!0,otherParticle.collided=!0
var c=o.mass+otherParticle.mass,d=new Particle(c,(o.x*o.mass+otherParticle.x*otherParticle.mass)/c,(o.y*o.mass+otherParticle.y*otherParticle.mass)/c,(o.vx*o.mass+otherParticle.vx*otherParticle.mass)/c,(o.vy*o.mass+otherParticle.vy*otherParticle.mass)/c)
t.push(d)}var m=otherParticle.mass/(l*l)
r+=m*a/l,i+=m*n/l}o.ax=r,o.ay=i}for(var u=0;u<particleList.length;u++)particleList[u].vx+=particleList[u].ax*h,particleList[u].vy+=particleList[u].ay*h,particleList[u].x+=particleList[u].vx*h,particleList[u].y+=particleList[u].vy*h,(particleList[u].collided||particleList[u].x<-50||particleList[u].y<-50||particleList[u].x>width+50||particleList[u].y>height+50)&&(particleList.splice(u,1),u--)
Array.prototype.push.apply(particleList,t)}function draw(){context.clearRect(0,0,width,height),context.beginPath(),context.moveTo(startCoords[0],startCoords[1]),context.lineTo(endCoords[0],endCoords[1]),context.strokeStyle="blue",context.strokeWidth=2,context.stroke()
for(var t=0;t<particleList.length;t++){var e=particleList[t]
context.beginPath(),context.arc(e.x,e.y,e.radius,0,2*Math.PI),context.closePath()
var o=e.color
if(e.radius<3)context.fillStyle="#"+o[3]
else{var r=context.createRadialGradient(e.x,e.y,.75*e.radius,e.x,e.y,e.radius)
r.addColorStop(0,"rgba("+o[0]+","+o[1]+","+o[2]+",1.0)"),r.addColorStop(1,"rgba("+o[0]+","+o[1]+","+o[2]+",0)"),context.fillStyle=r}context.fill()}}var h=.005,context,particleList=new Array,context,frametime,starttime,width,height,startCoords=[-1,-1],endCoords=[-1,-1],newMass=1e3,onControlBox=!1
